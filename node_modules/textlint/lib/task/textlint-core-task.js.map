{"version":3,"sources":["../../src/task/textlint-core-task.js"],"names":[],"mappings":"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","file":"textlint-core-task.js","sourcesContent":["// LICENSE : MIT\n\"use strict\";\nconst EventEmitter = require(\"events\");\nconst TraverseController = require(\"txt-ast-traverse\").Controller;\nconst PromiseEventEmitter = require(\"carrack\");\nconst traverseController = new TraverseController();\nconst debug = require(\"debug\")(\"textlint:core-task\");\nconst assert = require(\"assert\");\nimport RuleError from \"../core/rule-error\";\nimport SourceLocation from \"../core/source-location\";\nimport timing from \"./../util/timing\";\nimport MessageType from \"../shared/type/MessageType\";\nimport {throwWithoutExperimental} from \"../util/throw-log\";\n\n// Promised EventEmitter\nclass RuleTypeEmitter extends PromiseEventEmitter {\n    constructor() {\n        super();\n        this.setMaxListeners(0);\n    }\n}\n\n/**\n * CoreTask receive AST and prepare, traverse AST, emit nodeType event!\n * You can observe task and receive \"message\" event that is TextLintMessage.\n */\nexport default class TextLintCoreTask extends EventEmitter {\n    static get events() {\n        return {\n            // receive start event\n            start: \"start\",\n            // receive message from each rules\n            message: \"message\",\n            // receive complete event\n            complete: \"complete\",\n            // receive error event\n            error: \"error\"\n        };\n    }\n\n    constructor() {\n        super();\n        this.ruleTypeEmitter = new RuleTypeEmitter();\n    }\n\n    createIgnoreReporter() {\n        /**\n         * Message of ignoring\n         * @typedef {Object} ReportIgnoreMessage\n         * @property {string} ruleId\n         * @property {number[]} range\n         * @property {string} ignoringRuleId to ignore ruleId\n         * \"*\" is special case, it match all ruleId(work as wildcard).\n         */\n        /**\n         * create ReportIgnoreMessage and emit it.\n         * @param {ReportIgnoreMessage} reportedMessage\n         */\n        const reportFunction = (reportedMessage) => {\n            throwWithoutExperimental(\"shouldIgnore() is experimental feature.\\n\" +\n                \"You can use it with `--experimental` flag. It may will be changed in the future.\");\n            const {ruleId, range, optional} = reportedMessage;\n            assert(typeof range[0] !== \"undefined\" && typeof range[1] !== \"undefined\" && range[0] >= 0 && range[1] >= 0,\n                \"ignoreRange should have actual range: \" + range);\n            const message = {\n                type: MessageType.ignore,\n                ruleId: ruleId,\n                range: range,\n                // ignoring target ruleId - default: filter all messages\n                ignoringRuleId: optional.ruleId || \"*\"\n            };\n            this.emit(TextLintCoreTask.events.message, message);\n        };\n        return reportFunction;\n    }\n\n    createReporter(sourceCode) {\n        const sourceLocation = new SourceLocation(sourceCode);\n\n        /**\n         * @typedef {Object} ReportMessage\n         * @property {string} ruleId\n         * @property {TxtNode} node\n         * @property {number} severity\n         * @property {RuleError} ruleError error is a RuleError instance or any data\n         */\n        /**\n         * push new RuleError to results\n         * @param {ReportMessage} reportedMessage\n         */\n        const reportFunction = (reportedMessage) => {\n            const {ruleId, severity, ruleError} = reportedMessage;\n            debug(\"%s pushReport %s\", ruleId, ruleError);\n            const {line, column, fix} = sourceLocation.adjust(reportedMessage);\n            const index = sourceCode.positionToIndex({line, column});\n            // add TextLintMessage\n            const message = {\n                type: MessageType.lint,\n                ruleId: ruleId,\n                message: ruleError.message,\n                index,\n                // See https://github.com/textlint/textlint/blob/master/typing/textlint.d.ts\n                line: line,        // start with 1(1-based line number)\n                column: column + 1,// start with 1(1-based column number)\n                severity: severity // it's for compatible ESLint formatter\n            };\n            if (fix) {\n                message.fix = fix;\n            }\n            if (!(ruleError instanceof RuleError)) {\n                // `error` is a any data.\n                const data = ruleError;\n                message.data = data;\n            }\n            this.emit(TextLintCoreTask.events.message, message);\n        };\n        return reportFunction;\n    }\n\n    /**\n     * start process and emitting events.\n     * You can listen message by `task.on(\"message\", message => {})`\n     * @param {SourceCode} sourceCode\n     */\n    startTraverser(sourceCode) {\n        const promiseQueue = [];\n        const listenerCount = (typeof this.ruleTypeEmitter.listenerCount !== \"undefined\")\n            ? this.ruleTypeEmitter.listenerCount.bind(this.ruleTypeEmitter) // Node 4.x >=\n            : EventEmitter.listenerCount.bind(EventEmitter, this.ruleTypeEmitter);// Node 0.12\n        this.emit(TextLintCoreTask.events.start);\n        const ruleTypeEmitter = this.ruleTypeEmitter;\n        traverseController.traverse(sourceCode.ast, {\n            enter(node, parent) {\n                const type = node.type;\n                Object.defineProperty(node, \"parent\", {value: parent});\n                if (listenerCount(type) > 0) {\n                    const promise = ruleTypeEmitter.emit(type, node);\n                    promiseQueue.push(promise);\n                }\n            },\n            leave(node) {\n                const type = `${node.type}:exit`;\n                if (listenerCount(type) > 0) {\n                    const promise = ruleTypeEmitter.emit(type, node);\n                    promiseQueue.push(promise);\n                }\n            }\n        });\n        Promise.all(promiseQueue).then(() => {\n            this.emit(TextLintCoreTask.events.complete);\n        }).catch(error => {\n            this.emit(TextLintCoreTask.events.error, error);\n        });\n    }\n\n    /**\n     * try to get rule object\n     * @param {Function} ruleCreator\n     * @param {RuleContext|FilterRuleContext} ruleContext\n     * @param {Object|boolean} ruleConfig\n     * @returns {Object}\n     * @throws\n     */\n    tryToGetRuleObject(ruleCreator, ruleContext, ruleConfig) {\n        try {\n            return ruleCreator(ruleContext, ruleConfig);\n        } catch (error) {\n            error.message = `Error while loading rule '${ruleContext.id}': ${error.message}`;\n            throw error;\n        }\n    }\n\n    /**\n     * add all the node types as listeners of the rule\n     * @param {Function} ruleCreator\n     * @param {RuleContext|FilterRuleContext} ruleContext\n     * @param {Object|boolean} ruleConfig\n     * @returns {Object}\n     */\n    tryToAddListenRule(ruleCreator, ruleContext, ruleConfig) {\n        const ruleObject = this.tryToGetRuleObject(ruleCreator, ruleContext, ruleConfig);\n        Object.keys(ruleObject).forEach(nodeType => {\n            this.ruleTypeEmitter.on(nodeType, timing.enabled\n                ? timing.time(ruleContext.id, ruleObject[nodeType])\n                : ruleObject[nodeType]);\n        });\n    }\n}\n"]}